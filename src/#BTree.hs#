module BTree where


data BTree a = Empty | Node a (BTree a, BTree a) deriving (Show)

tell :: (Show a) => BTree a -> String
tell (Empty) = ""
tell (Node a (l, r)) = (show a) ++ " {" ++ tell l ++ "," ++ tell r ++ "}"

leaf a = Node a (Empty, Empty)

--Node a (Leaf l, Leaf r) = Node a (Leaf r, Leaf l)

contains :: (Ord a) => BTree a -> a -> Bool
contains Empty _ = False
contains (Node a (l, r)) v = case v `compare` a of EQ -> True
                                                   GT -> contains r v
                                                   LT -> contains l v

valueList :: BTree a -> [a]
valueList Empty = []
valueList (Node a (l, r)) = a : valueList l ++ valueList r


sort [] = []
sort [x] = [x]
sort (l:r:xs) = case l `compare` r of GT -> r : (sort $ l:xs)
                                      _ -> l : (sort $ r:xs)
unique [] = []
unique [x] = [x]
unique (l:r:xs)
	| l == r = unique $ r:xs
	| otherwise = l : (unique $ r:xs)

insert :: (Ord a) => a -> BTree a -> BTree a
insert v Empty = leaf v
insert v (Node a (l, r)) = case v `compare` a of EQ -> Node a (l, r)
                                                 GT -> Node a (l, insert v r)
                                                 LT -> Node a (insert v l, r)

rebalance :: (Ord a) => BTree a -> BTree a
rebalance tree = fromSortedList $ valueList tree

fromSortedList :: (Ord a) => [a] -> BTree a
fromList :: (Ord a) => [a] -> BTree a

fromList ar = fromSortedList . unique . sort $ ar
fromSortedList a = _fromSortedList a (length a)


_fromSortedList [] _ = Empty
_fromSortedList [x] _ = leaf x
_fromSortedList sa l = Node rh (_fromSortedList la left, _fromSortedList rt right) where
	left = l `div` 2
	right = l - left - 1
	(la, (rh:rt)) = splitAt left sa



test :: String
--test = show $ contains (Node 1 (Empty, leaf 2)) 2
test = 
	let tree = fromList [1,-9,3,8,2]
	--in show . unique . sort $ [1..5]
	in "tree " ++ (tell tree) ++ " contains 8: " ++ (show $ contains tree 8)
